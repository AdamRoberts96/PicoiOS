/**
 * @file
 * @author  David Llewellyn-Jones <David.Llewellyn-Jones@cl.cam.ac.uk>
 * @version 1.0
 *
 * @section LICENSE
 *
 * Copyright Pico project, 2016
 *
 * @section DESCRIPTION
 *
 * The MessageServiceReAuth class allows a Status message to ge generated by
 * the server to be sent to the Pico.
 * 
 * This represents a message sent as part of the continuous authentication
 * process.
 * QR-code (KeyAuth or KeyPair); Start; ServiceAuth; PicoAuth; Status;
 * Pico ReAuth; Service ReAuth (repeatedly).
 *
 * The structure of the message is as follows
 * {"iv":"B64","encryptedData":"B64-ENC","sessionId":0}
 * Where encryptedData contains the following sections
 * char reauthState | int timeout | length | char sequenceNumber[length]
 *
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "pico/debug.h"
#include "pico/cryptosupport.h"
#include "pico/json.h"
#include "pico/buffer.h"
#include "pico/base64.h"
#include "pico/log.h"
#include "pico/sequencenumber.h"
#include "pico/messageservicereauth.h"

// Defines

// Structure definitions

/**
 * Structure containing the private fields of the class.
 */
struct _MessageServiceReAuth {
	Buffer * sharedKey;
	int sessionId;

	SequenceNumber * sequenceNum;
	REAUTHSTATE reauthState;
	long int timeout; // 4-byte signed integer value
};

// Function prototypes

// Function definitions

/**
 * Create a new instance of the class.
 *
 * @return The newly created object.
 */
MessageServiceReAuth * messageservicereauth_new() {
	MessageServiceReAuth * messageservicereauth;

	messageservicereauth = CALLOC(sizeof(MessageServiceReAuth), 1);
	messageservicereauth->sharedKey = buffer_new(0);

	messageservicereauth->sessionId = 0;

	messageservicereauth->sequenceNum = sequencenumber_new();
	messageservicereauth->reauthState = REAUTHSTATE_INVALID;
	messageservicereauth->timeout = CONTINUOUS_TIMEOUT_ACTIVE;

	return messageservicereauth;
}

/**
 * Delete an instance of the class, freeing up the memory allocated to it.
 *
 * @param messageservicereauth The object to free.
 */
void messageservicereauth_delete(MessageServiceReAuth * messageservicereauth) {
	if (messageservicereauth) {
		if (messageservicereauth->sharedKey) {
			buffer_delete(messageservicereauth->sharedKey);
		}

		if (messageservicereauth->sequenceNum) {
			sequencenumber_delete(messageservicereauth->sequenceNum);
		}

		FREE(messageservicereauth);
	}
}

/**
 * Populate a Status message structure with the data it needs to be used.
 *
 * @param messageservicereauth The MessageServiceReAuth object to initalise
 * @param shared Object containing the data shared between all messages during
 *               the protocol run 
 * @param extraData string to be set as extra data
 */
void messageservicereauth_set(MessageServiceReAuth * messageservicereauth, Buffer * sharedKey, long int timeout, REAUTHSTATE reauthState, SequenceNumber const * sequenceNum) {
	buffer_clear(messageservicereauth->sharedKey);
	buffer_append_buffer(messageservicereauth->sharedKey, sharedKey);

	messageservicereauth->reauthState = reauthState;
	messageservicereauth->timeout = timeout;
	sequencenumber_copy(messageservicereauth->sequenceNum, sequenceNum);
}

/**
 * Serialize the Status data in JSON format.
 *
 * @param messageservicereauth The object for serialization
 * @param buffer Memory buffer to store the result in
 */
void messageservicereauth_serialize(MessageServiceReAuth * messageservicereauth, Buffer * buffer) {
	Json * json;
	Buffer * encrypted;
	Buffer * encoded;
	Buffer * iv;
	Buffer * toEncrypt;

	json = json_new();

	// Encrypted data
	toEncrypt = buffer_new(1);

	// Reauth State
	buffer_append(toEncrypt, & messageservicereauth->reauthState, 1);

	// Timeout
	buffer_append(toEncrypt, (char *)(& messageservicereauth->timeout) + 3, 1);
	buffer_append(toEncrypt, (char *)(& messageservicereauth->timeout) + 2, 1);
	buffer_append(toEncrypt, (char *)(& messageservicereauth->timeout) + 1, 1);
	buffer_append(toEncrypt, (char *)(& messageservicereauth->timeout) + 0, 1);
	
	// Sequence number
	buffer_append_lengthprepend(toEncrypt, sequencenumber_get_raw_bytes(messageservicereauth->sequenceNum), SEQUENCE_NUMBER_LENGTH);

	iv = buffer_new(CRYPTOSUPPORT_IV_SIZE);
	cryptosupport_generate_iv(iv);

	encrypted = buffer_new(0);
	//sharedKey = shared_get_shared_key(messageservicereauth->shared);
	cryptosupport_encrypt(messageservicereauth->sharedKey, iv, toEncrypt, encrypted);

	json_add_decimal(json, "sessionId", messageservicereauth->sessionId);

	encoded = buffer_new(0);
	base64_encode_buffer(encrypted, encoded);
	json_add_buffer(json, "encryptedData", encoded);

	buffer_clear(encoded);
	base64_encode_buffer(iv, encoded);
	json_add_buffer(json, "iv", encoded);

	json_serialize_buffer(json, buffer);
	json_delete(json);
	
	buffer_delete(toEncrypt);
	buffer_delete(encrypted);
	buffer_delete(encoded);
	buffer_delete(iv);
}


